---
description: "Diretrizes completas para desenvolvimento CoffeeScript - aplica-se automaticamente a arquivos CoffeeScript para garantir qualidade, consist√™ncia e boas pr√°ticas"
globs: **/*.coffee
alwaysApply: false
---

# CoffeeScript Development Guidelines

> **üìö Regra Especializada**: Esta regra aplica-se automaticamente a arquivos CoffeeScript para garantir qualidade, consist√™ncia e boas pr√°ticas de desenvolvimento.

## 1. Diretrizes Fundamentais

### 1.1 Indenta√ß√£o e Formata√ß√£o

**SEMPRE use** indenta√ß√£o de 2 espa√ßos para manter consist√™ncia
**SEMPRE evite** misturar tabs e espa√ßos
**SEMPRE mantenha** alinhamento consistente em blocos de c√≥digo
**SEMPRE limite** linhas a m√°ximo de 79 caracteres
**SEMPRE separe** defini√ß√µes de fun√ß√µes e classes com linha em branco
**SEMPRE evite** espa√ßos em branco no final das linhas
**SEMPRE use** UTF-8 como codifica√ß√£o padr√£o

**Por que esta regra existe**: Indenta√ß√£o consistente melhora legibilidade e evita erros de compila√ß√£o
**Automa√ß√£o**: Configure CoffeeLint para validar indenta√ß√£o automaticamente

```coffeescript
# ‚úÖ CORRETO: Indenta√ß√£o de 2 espa√ßos, linhas < 79 chars
class UserService
  constructor: (@apiClient) ->
    @users = []

  fetchUsers: ->
    @apiClient.get('/users')
      .then (response) =>
        @users = response.data
      .catch (error) =>
        console.error 'Erro ao buscar usu√°rios:', error

# ‚ùå INCORRETO: Indenta√ß√£o inconsistente, linha muito longa
class UserService
    constructor: (@apiClient) ->
        @users = []

  fetchUsers: ->
      @apiClient.get('/users')
      # Esta linha √© muito longa e excede o limite de 79 caracteres recomendado para CoffeeScript
```

### 1.2 Nomenclatura e Conven√ß√µes

**SEMPRE use** camelCase para vari√°veis e fun√ß√µes
**SEMPRE use** PascalCase para classes e construtores
**SEMPRE use** UPPER_CASE para constantes
**SEMPRE escolha** nomes descritivos e autoexplicativos

**Por que esta regra existe**: Nomenclatura consistente melhora legibilidade e manutenibilidade do c√≥digo
**Automa√ß√£o**: Configure CoffeeLint para validar padr√µes de nomenclatura

```coffeescript
# ‚úÖ CORRETO: Nomenclatura adequada
class ApiClient
  constructor: (@baseUrl) ->
    @MAX_RETRIES = 3
    @timeout = 5000

  fetchUserData: (userId) ->
    # Implementa√ß√£o

# ‚ùå INCORRETO: Nomes gen√©ricos e inconsistentes
class api
  constructor: (@url) ->
    @max = 3
    @t = 5000

  get: (id) ->
    # Implementa√ß√£o
```

### 1.3 Estrutura de Classes e Objetos

**SEMPRE defina** construtores claros com par√¢metros expl√≠citos
**SEMPRE use** `@` para propriedades de inst√¢ncia
**SEMPRE organize** m√©todos por funcionalidade
**SEMPRE use** heran√ßa quando apropriado

**Por que esta regra existe**: Estrutura clara de classes facilita manuten√ß√£o e extensibilidade
**Automa√ß√£o**: Configure CoffeeLint para validar estrutura de classes

```coffeescript
# ‚úÖ CORRETO: Estrutura de classe bem organizada
class BaseService
  constructor: (@apiClient, @config = {}) ->
    @isInitialized = false

  initialize: ->
    @isInitialized = true
    @onInitialized?()

  onInitialized: null

class UserService extends BaseService
  constructor: (apiClient, config) ->
    super apiClient, config
    @users = []

  fetchUsers: ->
    return unless @isInitialized
    @apiClient.get '/users'
```

### 1.4 Fun√ß√µes e M√©todos

**SEMPRE use** arrow functions (`=>`) para preservar contexto `this`
**SEMPRE use** fun√ß√µes normais (`->`) quando contexto n√£o importa
**SEMPRE documente** par√¢metros e retorno de fun√ß√µes complexas
**SEMPRE evite** fun√ß√µes aninhadas desnecess√°rias

**Por que esta regra existe**: Uso correto de fun√ß√µes evita problemas de contexto e melhora legibilidade
**Automa√ß√£o**: Configure CoffeeLint para validar uso de arrow functions

```coffeescript
# ‚úÖ CORRETO: Uso adequado de fun√ß√µes
class DataProcessor
  processData: (data, callback) ->
    # Fun√ß√£o normal para callback
    processedData = data.map (item) =>
      # Arrow function para preservar contexto
      @transformItem item

    callback? processedData

  transformItem: (item) ->
    # L√≥gica de transforma√ß√£o
    {
      id: item.id
      name: item.name?.toUpperCase()
      processed: true
    }

# ‚ùå INCORRETO: Uso inadequado de fun√ß√µes
class DataProcessor
  processData: (data, callback) ->
    # Misturando contextos incorretamente
    processedData = data.map (item) ->
      this.transformItem item  # 'this' n√£o se refere √† inst√¢ncia
```

### 1.5 Tratamento de Erros e Valida√ß√µes

**SEMPRE valide** par√¢metros de entrada
**SEMPRE use** try-catch para opera√ß√µes que podem falhar
**SEMPRE forne√ßa** mensagens de erro descritivas
**SEMPRE use** callbacks de erro consistentes
**SEMPRE implemente** tratamento de erros robusto para situa√ß√µes inesperadas
**SEMPRE gerencie** erros de forma graciosa

**Por que esta regra existe**: Tratamento robusto de erros previne falhas em produ√ß√£o e facilita debugging
**Automa√ß√£o**: Configure CoffeeLint para validar tratamento de erros

```coffeescript
# ‚úÖ CORRETO: Tratamento robusto de erros
class ApiService
  fetchData: (url, options = {}) ->
    try
      throw new Error 'URL √© obrigat√≥ria' unless url?
      throw new Error 'URL inv√°lida' unless @isValidUrl url

      @makeRequest url, options
        .then (response) =>
          @validateResponse response
        .catch (error) =>
          @handleError error, url
    catch error
      @handleError error, url

  isValidUrl: (url) ->
    /^https?:\/\/.+/.test url

  validateResponse: (response) ->
    throw new Error 'Resposta inv√°lida' unless response?.data?
    response

  handleError: (error, context) ->
    console.error "Erro em #{context}:", error.message
    throw error
```

### 1.6 Uso de Operadores e Sintaxe

**SEMPRE use** operadores de exist√™ncia (`?.`, `?=`) quando apropriado
**SEMPRE use** operadores de compara√ß√£o expl√≠citos (`is`, `isnt`)
**SEMPRE use** interpola√ß√£o de strings (`#{}`) para concatena√ß√£o
**SEMPRE evite** operadores amb√≠guos
**SEMPRE use** operadores booleanos consistentes (`&&`, `||` ou `and`, `or`)
**SEMPRE evite** par√™nteses e chaves desnecess√°rios
**SEMPRE use** `@` em vez de `this` para referenciar contexto atual

**Por que esta regra existe**: Uso correto de operadores CoffeeScript melhora legibilidade e previne erros
**Automa√ß√£o**: Configure CoffeeLint para validar uso de operadores

```coffeescript
# ‚úÖ CORRETO: Uso adequado de operadores
class UserManager
  updateUser: (userData) ->
    return unless userData?.id?

    user = @findUser userData.id
    return unless user?

    user.name = userData.name ? user.name
    user.email = userData.email ? user.email
    user.updatedAt = new Date()

    @saveUser user

  findUser: (id) ->
    @users?.find (user) => user.id is id

  saveUser: (user) ->
    console.log "Salvando usu√°rio: #{user.name} (#{user.id})"
    # L√≥gica de salvamento

# ‚ùå INCORRETO: Uso inadequado de operadores
class UserManager
  updateUser: (userData) ->
    # N√£o verifica exist√™ncia adequadamente
    user = this.findUser userData.id  # Usa 'this' em vez de '@'
    user.name = userData.name || user.name  # Usa || em vez de ?
    user.email = userData.email || user.email
```

### 1.7 Estruturas de Controle e Loops

**SEMPRE use** `for...in` para objetos
**SEMPRE use** `for...of` para arrays
**SEMPRE use** `when` para condi√ß√µes simples
**SEMPRE evite** loops aninhados desnecess√°rios

**Por que esta regra existe**: Estruturas de controle adequadas melhoram performance e legibilidade
**Automa√ß√£o**: Configure CoffeeLint para validar estruturas de controle

```coffeescript
# ‚úÖ CORRETO: Estruturas de controle adequadas
class DataAnalyzer
  analyzeData: (data) ->
    results = {}

    for item in data
      continue unless item?.isValid

      category = @categorizeItem item
      results[category] ?= []
      results[category].push item

    @processResults results

  categorizeItem: (item) ->
    switch item.type
      when 'user' then 'users'
      when 'product' then 'products'
      when 'order' then 'orders'
      else 'others'

  processResults: (results) ->
    for category, items of results
      console.log "#{category}: #{items.length} itens"
      @processCategory category, items
```

### 1.8 M√≥dulos e Namespaces

**SEMPRE use** padr√£o de m√≥dulo para encapsulamento
**SEMPRE evite** polui√ß√£o do namespace global
**SEMPRE exporte** apenas o necess√°rio
**SEMPRE use** namespaces para organiza√ß√£o
**SEMPRE organize** c√≥digo em m√≥dulos reutiliz√°veis
**SEMPRE siga** pr√°ticas recomendadas para estrutura√ß√£o de m√≥dulos

**Por que esta regra existe**: Encapsulamento adequado previne conflitos e facilita manuten√ß√£o
**Automa√ß√£o**: Configure CoffeeLint para validar padr√µes de m√≥dulo

```coffeescript
# ‚úÖ CORRETO: Padr√£o de m√≥dulo adequado
# namespace: App.Services
App = window.App ? {}
App.Services = App.Services ? {}

class App.Services.ApiClient
  constructor: (@baseUrl) ->
    @headers = {}

  setHeader: (key, value) ->
    @headers[key] = value

  get: (endpoint) ->
    # Implementa√ß√£o

# Exportar apenas o necess√°rio
window.App = App

# ‚ùå INCORRETO: Polui√ß√£o do namespace global
class ApiClient
  constructor: (@baseUrl) ->
    # Implementa√ß√£o

# Vari√°veis globais
apiClient = new ApiClient '/api'
```

### 1.9 Strings e Arrays

**SEMPRE use** interpola√ß√£o de strings em vez de concatena√ß√£o
**SEMPRE prefira** m√©todos nativos de array quando apropriado
**SEMPRE use** destructuring para arrays quando poss√≠vel
**SEMPRE evite** muta√ß√£o desnecess√°ria de arrays

**Por que esta regra existe**: Uso eficiente de strings e arrays melhora performance e legibilidade
**Automa√ß√£o**: Configure CoffeeLint para validar padr√µes de strings e arrays

```coffeescript
# ‚úÖ CORRETO: Uso eficiente de strings e arrays
class DataProcessor
  processItems: (items) ->
    # Interpola√ß√£o de string em vez de concatena√ß√£o
    message = "Processando #{items.length} itens"

    # Destructuring de array
    [first, second, ...rest] = items

    # M√©todos nativos de array
    validItems = items.filter (item) => item.isValid
    processedItems = validItems.map (item) => @transformItem item

    { message, first, second, rest, processedItems }

# ‚ùå INCORRETO: Uso ineficiente de strings e arrays
class DataProcessor
  processItems: (items) ->
    # Concatena√ß√£o de string
    message = "Processando " + items.length + " itens"

    # Acesso manual a elementos
    first = items[0]
    second = items[1]

    # Loops manuais em vez de m√©todos nativos
    validItems = []
    for item in items
      if item.isValid
        validItems.push item
```

### 1.10 Coment√°rios e Documenta√ß√£o

**SEMPRE documente** fun√ß√µes p√∫blicas complexas
**SEMPRE explique** l√≥gica de neg√≥cio n√£o √≥bvia
**SEMPRE use** coment√°rios de bloco para se√ß√µes grandes
**SEMPRE evite** coment√°rios √≥bvios

**Por que esta regra existe**: Documenta√ß√£o adequada facilita manuten√ß√£o e colabora√ß√£o em equipe
**Automa√ß√£o**: Configure CoffeeLint para validar padr√µes de documenta√ß√£o

```coffeescript
# ‚úÖ CORRETO: Coment√°rios √∫teis
class PaymentProcessor
  # Processa pagamento usando gateway espec√≠fico
  # @param paymentData {Object} Dados do pagamento
  # @param options {Object} Op√ß√µes de processamento
  # @returns {Promise} Promise com resultado do pagamento
  processPayment: (paymentData, options = {}) ->
    # Valida√ß√£o espec√≠fica para gateway brasileiro
    @validateBrazilianPayment paymentData

    # Configura√ß√£o de retry para falhas de rede
    retryCount = options.retryCount ? 3

    @attemptPayment paymentData, retryCount

  # Valida dados espec√≠ficos do pagamento brasileiro
  validateBrazilianPayment: (paymentData) ->
    throw new Error 'CPF obrigat√≥rio' unless paymentData.cpf?
    # Valida√ß√£o adicional...

# ‚ùå INCORRETO: Coment√°rios desnecess√°rios
class PaymentProcessor
  # Construtor da classe
  constructor: ->
    # Inicializa vari√°veis
    @initialized = false

  # Processa pagamento
  processPayment: (data) ->
    # Chama m√©todo de processamento
    @doProcess data
```

### 1.11 Performance e Otimiza√ß√£o

**SEMPRE evite** opera√ß√µes custosas em loops
**SEMPRE use** cache para opera√ß√µes repetitivas
**SEMPRE otimize** queries e chamadas de API
**SEMPRE monitore** performance de fun√ß√µes cr√≠ticas
**SEMPRE evite** chamadas de fun√ß√£o desnecess√°rias
**SEMPRE gerencie** manipuladores de eventos adequadamente
**SEMPRE evite** v√≠rgulas opcionais desnecess√°rias

**Por que esta regra existe**: Otimiza√ß√µes de performance melhoram experi√™ncia do usu√°rio e efici√™ncia do sistema
**Automa√ß√£o**: Configure ferramentas de profiling para monitorar performance

```coffeescript
# ‚úÖ CORRETO: Otimiza√ß√µes de performance
class DataCache
  constructor: ->
    @cache = {}
    @maxSize = 1000

  get: (key) ->
    return @cache[key] if @cache[key]?
    null

  set: (key, value) ->
    # Implementa LRU para evitar vazamentos de mem√≥ria
    if Object.keys(@cache).length >= @maxSize
      oldestKey = Object.keys(@cache)[0]
      delete @cache[oldestKey]

    @cache[key] = value

  # Cache de resultados de processamento pesado
  processHeavyData: (data) ->
    cacheKey = @generateCacheKey data
    cached = @get cacheKey
    return cached if cached?

    result = @performHeavyProcessing data
    @set cacheKey, result
    result
```

## 2. Anti-padr√µes a Evitar

### 2.1 Vari√°veis Globais

**SEMPRE evite** polui√ß√£o do namespace global
**SEMPRE use** encapsulamento adequado

**Por que esta regra existe**: Vari√°veis globais causam conflitos e dificultam manuten√ß√£o
**Automa√ß√£o**: Configure CoffeeLint para detectar vari√°veis globais

```coffeescript
# ‚ùå INCORRETO: Polui√ß√£o do namespace global
userData = {}
apiKey = 'secret'

# ‚úÖ CORRETO: Encapsulamento adequado
class App
  constructor: ->
    @userData = {}
    @apiKey = 'secret'
```

### 2.2 Callback Hell

**SEMPRE evite** callbacks aninhados excessivos
**SEMPRE use** Promises ou async/await

**Por que esta regra existe**: Callback hell dificulta leitura e manuten√ß√£o do c√≥digo
**Automa√ß√£o**: Configure CoffeeLint para detectar callbacks aninhados

```coffeescript
# ‚ùå INCORRETO: Callbacks aninhados
getUserData: (id) ->
  @api.getUser id, (user) ->
    @api.getOrders user.id, (orders) ->
      @api.getProducts orders[0].productId, (product) ->
        # L√≥gica complexa aninhada

# ‚úÖ CORRETO: Uso de Promises ou async/await
getUserData: (id) ->
  @api.getUser(id)
    .then (user) => @api.getOrders user.id
    .then (orders) => @api.getProducts orders[0].productId
    .then (product) =>
      # L√≥gica organizada
```

### 2.3 Muta√ß√£o de Par√¢metros

**SEMPRE evite** muta√ß√£o direta de par√¢metros
**SEMPRE use** imutabilidade quando poss√≠vel

**Por que esta regra existe**: Muta√ß√£o de par√¢metros causa efeitos colaterais inesperados
**Automa√ß√£o**: Configure CoffeeLint para detectar muta√ß√µes de par√¢metros

```coffeescript
# ‚ùå INCORRETO: Muta√ß√£o de par√¢metros
processData: (data) ->
  data.processed = true  # Muta√ß√£o direta
  data.timestamp = Date.now()
  data

# ‚úÖ CORRETO: Imutabilidade
processData: (data) ->
  {
    data...
    processed: true
    timestamp: Date.now()
  }
```

## 3. Checklist de Qualidade

### 3.1 Antes de Commitar

- [ ] **Indenta√ß√£o consistente** de 2 espa√ßos
- [ ] **Linhas limitadas** a 79 caracteres
- [ ] **Nomenclatura adequada** (camelCase, PascalCase)
- [ ] **Tratamento de erros** robusto implementado
- [ ] **Interpola√ß√£o de strings** em vez de concatena√ß√£o
- [ ] **Operadores booleanos** consistentes
- [ ] **Uso de `@`** em vez de `this`
- [ ] **Coment√°rios √∫teis** adicionados
- [ ] **Performance otimizada** para opera√ß√µes cr√≠ticas
- [ ] **Testes unit√°rios** para fun√ß√µes complexas
- [ ] **Documenta√ß√£o atualizada** se necess√°rio

### 3.2 Revis√£o de C√≥digo

- [ ] **Estrutura de classes** bem organizada
- [ ] **Fun√ß√µes pequenas** e focadas
- [ ] **Reutiliza√ß√£o de c√≥digo** adequada
- [ ] **Padr√µes de m√≥dulo** seguidos
- [ ] **Anti-padr√µes evitados**

**Por que estas regras existem**: Checklist garante qualidade e consist√™ncia do c√≥digo
**Automa√ß√£o**: Configure pre-commit hooks para valida√ß√£o autom√°tica

## 4. Ferramentas e Recursos

### 4.1 Linting e Formata√ß√£o

- **CoffeeLint**: Linter espec√≠fico para CoffeeScript com regras de estilo
- **Prettier**: Formata√ß√£o autom√°tica de c√≥digo
- **ESLint**: Para c√≥digo JavaScript compilado
- **CoffeeScript Style Guide**: Guia oficial de estilo

### 4.2 Testes

- **Jasmine**: Framework de testes para CoffeeScript
- **Mocha**: Framework alternativo
- **Chai**: Biblioteca de assertions

### 4.3 Build Tools

- **Webpack**: Bundling e otimiza√ß√£o
- **Gulp**: Task runner para automa√ß√£o
- **Grunt**: Alternativa ao Gulp

**Por que estas regras existem**: Ferramentas adequadas facilitam desenvolvimento e manuten√ß√£o
**Automa√ß√£o**: Configure scripts de build para automatizar tarefas

## 5. Refer√™ncias

- [CoffeeScript Official Guide](http://coffeescript.org/)
- [CoffeeScript Style Guide](https://github.com/polarmobile/coffeescript-style-guide)
- [CoffeeScript Cookbook](https://coffeescript-cookbook.github.io/)

**Por que estas regras existem**: Refer√™ncias facilitam aprendizado e melhoria cont√≠nua
**Automa√ß√£o**: Configure ferramentas para manter refer√™ncias atualizadas

---

**√öltima atualiza√ß√£o**: 2025-01-11
**Vers√£o**: 1.0.0
**Aplica√ß√£o**: Autom√°tica em arquivos `.coffee`

---
description: Boas pr√°ticas React para desenvolvimento frontend
globs: src/**/*.tsx,src/**/*.jsx
---

# React Rule ‚Äî Boas Pr√°ticas

## üó£Ô∏è Defini√ß√£o de papel

- Padroniza boas pr√°ticas de desenvolvimento React para projetos frontend.

## üéØ PRINC√çPIOS FUNDAMENTAIS

- **Objetivo**: garantir legibilidade, consist√™ncia e performance em componentes React.
- **Escopo**: aplica-se a arquivos `src/**/*.tsx` e `src/**/*.jsx` em projetos React.
- **Prefer√™ncias**: componentes funcionais, TypeScript, hooks, acessibilidade e testes com RTL.

## üîÑ FLUXO / PROCESSO

1. Criar componentes funcionais pequenos e focados.
2. Extrair l√≥gica reutiliz√°vel em hooks.
3. Tipar props e estado com TypeScript.
4. Otimizar render (memoiza√ß√£o) quando necess√°rio.
5. Cobrir fluxos cr√≠ticos com testes de intera√ß√£o (RTL).

## üìä FORMATO DE SA√çDA

- Arquivos `*.tsx|*.jsx` em `src/components/**` ou locais ao contexto.
- Nomea√ß√£o em `kebab-case` para arquivos; exports nomeados ou default coerentes.

## ‚úÖ CHECKLIST DE QUALIDADE

- [ ] Componente funcional, coeso e pequeno; sem responsabilidades m√∫ltiplas.
- [ ] Props e estado tipados; evitar `any`.
- [ ] Hooks seguindo as regras (ordem est√°vel, deps do `useEffect` corretas, cleanup quando necess√°rio).
- [ ] Estado pr√≥ximo do consumidor; `useState` para local, `useReducer` para l√≥gica complexa e Context API para compartilhado; evitar prop drilling excessivo.
- [ ] Performance: `useMemo`/`useCallback`/`React.memo` quando √∫til; lazy loading; `key` adequadas; evitar re-renders desnecess√°rios.
- [ ] Formul√°rios: componentes controlados, valida√ß√£o, estados de envio/erro e acessibilidade.
- [ ] Tratamento de erros: Error Boundaries, mensagens amig√°veis, UI de fallback e logging apropriado.
- [ ] Testes (React Testing Library): intera√ß√µes principais, cen√°rios de erro e mocks adequados.
- [ ] Acessibilidade: sem√¢ntica, ARIA adequada, navega√ß√£o por teclado e gest√£o de foco.
- [ ] Organiza√ß√£o de c√≥digo: nomea√ß√£o de arquivos, estrutura de diret√≥rios, estilos pr√≥ximos ao componente e imports corretos.
- [ ] Imports limpos; sem c√≥digo morto.

## üó£Ô∏è PADR√ïES DE COMUNICA√á√ÉO

- Commits claros e at√¥micos; mensagens no imperativo curto.
- PRs com resumo objetivo do impacto e escopo.

## üß† NOTAS / LEMBRETES

- Manter estado o mais pr√≥ximo do consumidor; evitar prop drilling excessivo.
- Usar Context API para estado compartilhado quando necess√°rio.
- Usar bibliotecas de estilo consistentes (Tailwind, Styled Components, CSS Modules, etc.).

## üîó REFER√äNCIAS

- [React Documentation](https://react.dev/)
- [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)
- [TypeScript Handbook](https://www.typescriptlang.org/docs/)

## üéØ ESTRUTURA DE COMPONENTES

**SEMPRE siga estrutura consistente**:

```tsx
// 1. Imports
import React, { useState, useEffect } from "react";
import { Button } from "@/components/Button";
import type { User } from "@/types/user";

// 2. Interfaces/Types
interface UserCardProps {
  user: User;
  onEdit: (user: User) => void;
  onDelete: (id: string) => void;
}

// 3. Componente
export const UserCard: React.FC<UserCardProps> = ({
  user,
  onEdit,
  onDelete,
}) => {
  // 4. Hooks
  const [isEditing, setIsEditing] = useState(false);

  // 5. Handlers
  const handleEdit = () => {
    setIsEditing(true);
    onEdit(user);
  };

  // 6. Effects
  useEffect(() => {
    // Effect logic
  }, []);

  // 7. Render
  return <div className="user-card">{/* JSX */}</div>;
};
```

**Diretrizes**:

- Prefira componentes funcionais a componentes de classe
- Mantenha componentes pequenos e focados (<200 linhas)
- Extraia l√≥gica reutiliz√°vel em hooks customizados
- Use composi√ß√£o em vez de heran√ßa
- Tipagem adequada de props com TypeScript
- Divida componentes grandes em partes menores e focadas

## üé£ HOOKS E ESTADO

**SEMPRE use hooks apropriadamente**:

- **SEMPRE use `useState`** para estado local
- **SEMPRE use `useEffect`** com depend√™ncias corretas
- **SEMPRE use `useCallback`** para fun√ß√µes passadas como props
- **SEMPRE use `useMemo`** para c√°lculos custosos
- **SEMPRE use `useRef`** para refer√™ncias DOM

```tsx
// ‚úÖ CORRETO
const UserList: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [loading, setLoading] = useState(false);

  const fetchUsers = useCallback(async () => {
    setLoading(true);
    try {
      const data = await UserService.getUsers();
      setUsers(data);
    } finally {
      setLoading(false);
    }
  }, []);

  const filteredUsers = useMemo(
    () => users.filter((user) => user.active),
    [users]
  );

  useEffect(() => {
    fetchUsers();
  }, [fetchUsers]);

  return (
    <div>{loading ? <Spinner /> : <UserGrid users={filteredUsers} />}</div>
  );
};
```

**Diretrizes**:

- Siga as Regras dos Hooks
- Use hooks customizados para l√≥gica reutiliz√°vel
- Mantenha hooks focados e simples
- Defina corretamente os arrays de depend√™ncias no `useEffect`
- Implemente cleanup no `useEffect` quando necess√°rio
- Evite hooks aninhados
- Use `useState` para estado local do componente
- Use `useReducer` para l√≥gica de estado complexa
- Use Context API para estado compartilhado
- Mantenha o estado o mais pr√≥ximo poss√≠vel de onde √© usado
- Evite prop drilling com uma ger√™ncia de estado adequada
- Use bibliotecas de estado apenas quando necess√°rio

## üé® PROPS E COMPOSI√á√ÉO

**SEMPRE use props tipadas e composi√ß√£o**:

- **SEMPRE defina interfaces** para props
- **SEMPRE use children** quando apropriado
- **SEMPRE use defaultProps** ou valores padr√£o
- **SEMPRE desestruture props** para clareza

```tsx
// ‚úÖ CORRETO
interface CardProps {
  title: string;
  children: React.ReactNode;
  variant?: "primary" | "secondary";
  className?: string;
}

export const Card: React.FC<CardProps> = ({
  title,
  children,
  variant = "primary",
  className = "",
}) => {
  return (
    <div className={`card card--${variant} ${className}`}>
      <h3 className="card__title">{title}</h3>
      <div className="card__content">{children}</div>
    </div>
  );
};
```

## üöÄ PERFORMANCE

**SEMPRE otimize para performance**:

- **SEMPRE use `React.memo`** para componentes puros
- **SEMPRE use `useCallback`** para fun√ß√µes em props
- **SEMPRE use `useMemo`** para c√°lculos custosos
- **SEMPRE evite** re-renders desnecess√°rios

```tsx
// ‚úÖ CORRETO
const ExpensiveComponent = React.memo<{ data: ComplexData }>(({ data }) => {
  const processedData = useMemo(() => processComplexData(data), [data]);

  return <div>{/* Render processed data */}</div>;
});

const ParentComponent = () => {
  const [count, setCount] = useState(0);
  const [data, setData] = useState<ComplexData>(initialData);

  const handleDataChange = useCallback((newData: ComplexData) => {
    setData(newData);
  }, []);

  return (
    <div>
      <button onClick={() => setCount((c) => c + 1)}>Count: {count}</button>
      <ExpensiveComponent data={data} />
    </div>
  );
};
```

**Diretrizes**:

- Aplique memoiza√ß√£o adequada (`useMemo`, `useCallback`)
- Use `React.memo` para componentes custosos
- Evite re-renderiza√ß√µes desnecess√°rias
- Implemente lazy loading quando fizer sentido
- Use chaves (`key`) corretas em listas
- Fa√ßa profiling e otimize a performance de renderiza√ß√£o

## üìù FORMUL√ÅRIOS

**SEMPRE use componentes controlados e valida√ß√£o**:

- Use componentes controlados para inputs
- Implemente valida√ß√£o adequada de formul√°rios
- Gerencie corretamente estados de envio
- Exiba estados de loading e erro apropriados
- Use bibliotecas para formul√°rios complexos
- Garanta acessibilidade adequada em formul√°rios

## ‚ö†Ô∏è TRATAMENTO DE ERROS

**SEMPRE implemente tratamento de erros robusto**:

- Implemente Error Boundaries
- Trate erros ass√≠ncronos adequadamente
- Exiba mensagens de erro amig√°veis
- Forne√ßa UI de fallback apropriada
- Fa√ßa logging de erros de forma adequada
- Trate casos de borda com cuidado

## üß™ TESTES

**SEMPRE escreva testes abrangentes**:

- **SEMPRE teste** comportamento, n√£o implementa√ß√£o
- **SEMPRE use** `@testing-library/react`
- **SEMPRE teste** casos extremos e intera√ß√µes
- **SEMPRE mocke** depend√™ncias externas

```tsx
// ‚úÖ CORRETO
import { render, screen, fireEvent } from "@testing-library/react";
import { UserCard } from "./UserCard";

describe("UserCard", () => {
  const mockUser: User = {
    id: "1",
    name: "John Doe",
    email: "john@example.com",
  };

  const mockOnEdit = jest.fn();
  const mockOnDelete = jest.fn();

  it("should render user information", () => {
    render(
      <UserCard user={mockUser} onEdit={mockOnEdit} onDelete={mockOnDelete} />
    );

    expect(screen.getByText("John Doe")).toBeInTheDocument();
    expect(screen.getByText("john@example.com")).toBeInTheDocument();
  });

  it("should call onEdit when edit button is clicked", () => {
    render(
      <UserCard user={mockUser} onEdit={mockOnEdit} onDelete={mockOnDelete} />
    );

    fireEvent.click(screen.getByText("Edit"));
    expect(mockOnEdit).toHaveBeenCalledWith(mockUser);
  });
});
```

**Diretrizes**:

- Escreva testes de unidade para componentes
- Crie testes de integra√ß√£o para fluxos complexos
- Use React Testing Library
- Teste intera√ß√µes do usu√°rio
- Teste cen√°rios de erro
- Use mocks de dados adequados

## ‚ôø ACESSIBILIDADE

**SEMPRE garanta acessibilidade**:

- Use elementos sem√¢nticos de HTML
- Defina atributos ARIA adequados
- Garanta navega√ß√£o por teclado
- Teste com leitores de tela
- Gerencie foco de forma adequada
- Forne√ßa texto alternativo (alt) correto para imagens

## üìÅ ORGANIZA√á√ÉO DE C√ìDIGO

**SEMPRE mantenha organiza√ß√£o clara**:

- Agrupe componentes relacionados
- Use conven√ß√µes de nome de arquivo consistentes
- Estruture diret√≥rios de forma clara
- Mantenha estilos pr√≥ximos aos componentes
- Use imports/exports adequados
- Documente l√≥gica de componentes complexos

## üö´ ANTI-PATTERNS A EVITAR

**NUNCA fa√ßa**:

- [ ] Use `useEffect` sem depend√™ncias adequadas
- [ ] Muta√ß√£o direta de estado
- [ ] Crie componentes muito grandes (>200 linhas)
- [ ] Use `key` inadequada em listas
- [ ] Ignore warnings do React
- [ ] Use `any` para props de componentes
